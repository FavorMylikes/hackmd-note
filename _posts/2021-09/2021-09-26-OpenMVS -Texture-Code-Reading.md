---
layout: single
title:  "OpenMVS Texture code reading"
date:   "2021-09-26 19:51:42 +0800"
categories: 3d
header:
  teaser: https://raw.githubusercontent.com/FavorMylikes/hackmd-note/img/img20210928142744.png
---

- TextureMesh
  - FaceViewSelection
    - ListVertexFacesâœ”ï¸ // extract array of triangles incident to each vertex
      - EmptyExtraâœ”ï¸
      - ListIncidenteFacesâœ”ï¸
      - ListBoundaryVerticesâœ”ï¸, // è¾¹ç•Œç‚¹æ£€æŸ¥ï¼Œåœ¨é¢ä¸­ï¼Œåªä½¿ç”¨äº†1æ¬¡çš„ç‚¹æ˜¯è¾¹ç•Œç‚¹ï¼Œå¦å¤–ï¼Œä»£ç ä¸­å‡è®¾æ¯ä¸ªç‚¹é€šå¸¸ä¸ä¼šè¶…è¿‡12ä¸ªé¢ä½¿ç”¨
        - <img src="https://raw.githubusercontent.com/FavorMylikes/hackmd-note/img/img20210926235332.png" alt="20210926235332"/>
    - // create texture patches
      - ListCameraFaces // list all views for each face
        - //create vertices **octree** of verticesâœ”ï¸
        - //extract array of faces viewed by each imageâœ”ï¸
          - //compute gradient magnitudeâœ”ï¸
          - //select faces inside view frustumâœ”ï¸
            - plane with `AABB`âœ”ï¸
          - // project all triangles in this view and keep the closest ones
            - // skip face if not completely insideâœ”ï¸
              - using `TransformPointW2C` and `TransformPointC2I` to check the point is in image plane, `OpenMVS` use 3 pixel as border width âœ”ï¸
            - // skip face if the (cos) angle between the view to face vector and the view direction is negativeâœ”ï¸
              - `(faceCenter.z <= REAL(0))`
              - `faceCenter.dot(normalPlane) >= ZEROTOLERANCE<REAL>()`
            - // draw triangle and for each pixel compute depth as the ray intersection with the planeâœ”ï¸
              - **`Advanced Rasterization`** by Nick (Nicolas Capens) 2004
              - [Advanced Rasterization](https://forum.beyond3d.com/threads/advanced-rasterization.12507/)ğŸ¤”
              - `libs/Common/Types.inl:2474/TImage<TYPE>::RasterizeTriangle`
              - **OpenMVS: Using block size eq 8, and `Half-Space`**
          - // compute the projection area of visible faces
            - éå†ç…§ç‰‡ä¸Šçš„åƒç´ ï¼Œè·å–æœ€è¿‘çš„`face`æœ€è¿‘çš„view, è®¡ç®—`face`é¢œè‰²å‡å€¼âœ”ï¸
          - `(fOutlierThreshold > 0)` // try to detect outlier views for each face
            - å–face 3ä¸ªé€šé“çš„å‡è‰²ï¼Œå¯¹å‡è‰²åšå¤šå…ƒæ­£å¤ªåˆ†å¸ƒè®¡ç®—ï¼Œå¦‚æœåå·®å¤§äºé˜ˆå€¼ï¼Œåˆ™è§†ä¸º`outlier`âœ”ï¸
              - `LUåˆ†è§£`å–é€†
    - // create faces graphâœ”ï¸
      - éå†`face`ä»¥åŠé¢çš„é‚»æ¥`faceAdj`, è‹¥ä¸€ä¸ªå¯è§ï¼Œä¸€ä¸ªä¸å¯è§ï¼Œåˆ™å¢åŠ `seam`
    - // assign the best view to each faceâœ”ï¸
      - // find connected componentsâœ”ï¸
        - æ ¹æ®å‰é¢è®¡ç®—çš„`face`é‚»æ¥å…³ç³»è®¡ç®—è¿é€šå›¾
      - // map face ID from global to component spaceâœ”ï¸
        - ä¸ºæ¯ä¸ªé¢è®¡ç®—è¿é€šå›¾çš„æ–°idï¼Œ`component1: [1,2,3,...,c1], component2: [1,2,3,...,c2]`
      - // normalize quality valuesâœ”ï¸
        - è®¡ç®—å›¾ç‰‡è´¨é‡[äºŒé˜¶å¯¼ç§¯åˆ†]çš„95åˆ†ä½ç½®è¿‘ä¼¼å€¼
      - // initialize inference structuresâœ”ï¸
        - `numNodes`=è¿é€šå›¾faceçš„æ•°é‡ï¼Œå¦‚æœæ•°é‡å°äºç­‰äº1ï¼Œåˆ™å¿½ç•¥
        - `SmoothCost`=0[if node eq]~1000
        - `Neighbors`
      - // set data costsâœ”ï¸
        - // set costs for label 0 (undefined)âœ”ï¸
          - `dataCost = fRatioDataSmoothness * 1000` for min of all labels
        - // set data costs for all labels (except label 0 - undefined)âœ”ï¸
          - `dataCost =` $\big(1-\max(1, \frac{quality}{quality_{p95}})\big)*1000$
        - Label = 0, æœªå®šä¹‰ï¼Œlabel >= 1æ˜¯æŒ‡å…¶ä»–å›¾ç‰‡âœ”ï¸
      - // assign the optimal view (label) to each faceâœ”ï¸
        - `Optimize` ä¼˜åŒ–å•ä½æ˜¯è¿é€šå›¾âœ”ï¸
          - `ComputeEnergy`âœ”ï¸
            - $\sum{cost_{data}} + \sum(cost_{edge})$
            - $cost_{edge} = 1000$ if label is not equal
          - `Optimize(n=1)`âœ”ï¸
            - for(n times)
              - è®¡ç®—æ¯ä¸ªé¢åœ¨é€‰æ‹©ä¸åŒ`label`æ—¶å¾—åˆ°çš„`minEnergy`
              - `Swap` `newMsgs` and `oldMsgs`, `oldMsgs - min(oldMsgs)`
            - æ›´æ–°é€‰æ‹©çš„`label`å’Œ`dataCost`âœ”ï¸
          - æ ¹æ®èƒ½é‡å·®åˆ†æå‰è¿”å›âœ”ï¸
      - // extract resulting labelingâœ”ï¸
        - label-1ï¼Œè°ƒæ•´ç´¢å¼•
    - // create texture patchesâœ”ï¸
      - // divide graph in sub-graphs of connected faces having the same labelâœ”ï¸
        - è®¡ç®—å›¾ç‰‡ä¸ä¸€è‡´çš„è¾¹ç¼`A`ï¼Œå¯¹äºç›¸é‚»ä¸€ä¾§æ— labelçš„ä¹Ÿä½œä¸ºè¾¹ç¼`B`
        - å»æ‰`A`çš„è¿é€šè¾¹
      - // find connected components: texture patchesâœ”ï¸
        - è®¡ç®—æ–°çš„è¿é€šå›¾
      - // last texture patch contains all faces with no textureâœ”ï¸
        - æ¯ä¸ª`Texture` æ”¶é›†æ¯ä¸ªè¿é€šä½“çš„`face`
      - // remove all patches with invalid label (except the last one) and create the map from the old index to the new oneâœ”ï¸
  - GenerateTexture
    - // project patches in the corresponding view and compute texture-coordinates and bounding-box
    - // project vertices and compute bounding-boxâœ”ï¸
      - å¯¹æ¯ä¸ª`patch`çš„é¢æ˜ å°„åˆ°å›¾ç‰‡ä¸­åï¼Œç®—ä¸€ä¸ª2dçš„`aabb`
    - // compute relative texture coordinatesâœ”ï¸
      - è®¡ç®—offsetï¼Œä¿®æ”¹ç›¸åº”çš„åæ ‡
    - // init last patch to point to a small uniform color patchâœ”ï¸
      - é»˜è®¤çº¹ç†ä½ç½®
    - // perform seam leveling
      - // create seam vertices and edgesâœ”ï¸
      - // perform global seam leveling
        - // find the patch ID for each vertexâœ”ï¸
          - å¯¹ç‚¹èµ‹å€¼patch_idï¼Œè¾¹ç¼ç‚¹ä½¿ç”¨`idxSeamVertex`
        - // assign a row index within the solution vector x to each vertex/patch
          - ç”Ÿæˆä¸€ä¸ªpatchæ•°ç»„`vertpatch2rows`, è¡Œå·ä¸ºç‚¹ç´¢å¼•ï¼ŒäºŒé˜¶ç´¢å¼•ä¸ºpatchï¼Œå¯¹äºå•ä¸ª`patch`çš„ç‚¹ï¼Œåªèµ‹å€¼ä¸€ä¸ªpatchï¼Œå¯¹äºè¾¹ç¼ç‚¹å¤šä¸ª`patch`çš„ç‚¹ï¼Œèµ‹å¤šä¸ª`patch`ï¼Œå€¼ä¸ºé€’å¢å€¼`rowsX`
        - // fill Tikhonov's Gamma matrix (regularization constraints)
      - // perform local seam leveling
    - // merge texture patches with overlapping rectangles
      - // translate texture coordinates
      - // join faces lists
      - // remove the small patch
    - // create texture
      - // arrange texture patches to fit the smallest possible texture image
      - // increase texture size till all patches fit
    - // create texture image
      - // copy patch image
        - // flip patch and texture-coordinates
      - // compute final texture coordinates
        - // translate, normalize and flip Y axis